# RestaurantPulse — Development Roadmap & Handover Document

> **Last updated:** February 2026
> **Branch:** `claude/hosting-platform-decision-P7TSB`
> **Platform:** Railway (PostgreSQL + Node.js)
> **Purpose:** This document gives any developer a complete picture of what has been built, what still needs to be built, and exactly how to build it — following the patterns already established in the codebase.

---

## Table of Contents

1. [Project Overview](#1-project-overview)
2. [Tech Stack](#2-tech-stack)
3. [Repository Structure](#3-repository-structure)
4. [How the Codebase Is Organised](#4-how-the-codebase-is-organised)
5. [Development Workflow](#5-development-workflow)
6. [Current State — What Is Already Built](#6-current-state--what-is-already-built)
7. [Module Build Status](#7-module-build-status)
8. [Completed Module: Inventory & Waste Management](#8-completed-module-inventory--waste-management)
9. [Module 2: Staff Labor Scheduling & Efficiency](#9-module-2-staff-labor-scheduling--efficiency)
10. [Module 3: Cash Flow Forecasting (12-week)](#10-module-3-cash-flow-forecasting-12-week)
11. [Module 4: Marketing Attribution & Promotion ROI](#11-module-4-marketing-attribution--promotion-roi)
12. [Module 5: Customer Intelligence & Lifetime Value](#12-module-5-customer-intelligence--lifetime-value)
13. [Module 6: Predictive Analytics & Demand Forecasting](#13-module-6-predictive-analytics--demand-forecasting)
14. [Module 7: POS & Accounting Integrations](#14-module-7-pos--accounting-integrations)
15. [Architecture Patterns — How to Add a New Module](#15-architecture-patterns--how-to-add-a-new-module)
16. [Database Schema Reference](#16-database-schema-reference)
17. [API Endpoints Reference](#17-api-endpoints-reference)
18. [Railway Deployment Notes](#18-railway-deployment-notes)
19. [Cost Management Principles](#19-cost-management-principles)

---

## 1. Project Overview

**RestaurantPulse** (codebase folder: `Flivio`) is a SaaS platform for restaurant intelligence. It helps restaurant owners and franchise operators understand their costs, profit margins, supplier risks, staff efficiency, and business performance.

**Target users:**
- Independent restaurant owners
- Multi-site restaurant groups
- Franchise operators (both franchisors and franchisees)

**Business model:** Monthly SaaS subscription via Railway hosting. Subscription tiers exist in the schema (`starter`, `professional`, `enterprise`) but payment processing (Stripe) has not yet been integrated.

---

## 2. Tech Stack

| Layer | Technology | Version |
|---|---|---|
| Frontend framework | React | 18.3.1 |
| Frontend build | Vite | 7.x |
| Frontend routing | wouter | lightweight, not React Router |
| Server state | TanStack React Query | 5.x |
| UI components | shadcn/ui + Tailwind CSS | — |
| Charts | Recharts | 2.x |
| Forms | React Hook Form + Zod | — |
| Backend framework | Express.js | 5.x |
| Language | TypeScript (full stack) | — |
| ORM | Drizzle ORM | 0.39.x |
| Database | PostgreSQL | — |
| Auth | Passport.js (local strategy) + bcryptjs | — |
| Sessions | express-session (MemoryStore) | — |
| Hosting | Railway | — |

---

## 3. Repository Structure

```
Flivio/
├── client/                        # React frontend
│   └── src/
│       ├── pages/                 # One file per page/route (27 pages currently)
│       ├── components/
│       │   ├── app-sidebar.tsx    # Main navigation sidebar
│       │   ├── theme-toggle.tsx
│       │   └── ui/                # 50+ shadcn/ui components (do not modify)
│       ├── hooks/
│       │   ├── use-mobile.tsx
│       │   └── use-toast.ts
│       ├── lib/
│       │   ├── queryClient.ts     # apiRequest() helper + React Query config
│       │   └── theme-provider.tsx
│       └── main.tsx
├── server/
│   ├── index.ts                   # Server entry point, middleware setup
│   ├── routes.ts                  # ALL API route handlers (~1100 lines)
│   ├── storage.ts                 # Database abstraction layer (IStorage interface + DatabaseStorage class)
│   ├── auth.ts                    # Register / login / logout
│   ├── db.ts                      # Drizzle ORM db connection
│   ├── seed.ts                    # Default data seeding
│   └── vite.ts                    # Dev server integration
├── shared/
│   └── schema.ts                  # Database tables, insert schemas, TypeScript types
├── migrations/                    # Auto-generated by Drizzle Kit
├── script/
│   └── build.ts                   # Production build script
├── package.json
├── drizzle.config.ts
├── vite.config.ts
└── DEVELOPMENT_ROADMAP.md         # This file
```

---

## 4. How the Codebase Is Organised

### The three-layer pattern

Every feature in this app follows the same three-layer pattern. **Always follow this pattern when adding new features.**

```
shared/schema.ts          ← 1. Define the database table + TypeScript types
       ↓
server/storage.ts         ← 2. Add CRUD methods to IStorage interface + DatabaseStorage class
       ↓
server/routes.ts          ← 3. Add Express route handlers that call storage methods
       ↓
client/src/pages/*.tsx    ← 4. Build the React page using useQuery / useMutation
       ↓
client/src/App.tsx        ← 5. Add the route
client/src/components/
  app-sidebar.tsx         ← 6. Add the sidebar navigation link
```

### How React Query fetches data

The `queryClient.ts` default `queryFn` joins the `queryKey` array with `/` to form the URL:

```ts
// This query:
useQuery({ queryKey: ["/api/waste-logs", restaurantId] })
// Fetches: GET /api/waste-logs/1
```

So API routes must be structured as `/api/resource/:id` where `:id` is the last segment, matching what `queryKey.join("/")` produces.

### The apiRequest helper

```ts
import { apiRequest } from "@/lib/queryClient";

// Usage in mutations:
useMutation({
  mutationFn: (data) => apiRequest("POST", "/api/inventory-items", data),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ["/api/inventory-items", restaurantId] });
    toast({ title: "Done" });
  },
});
```

### Getting the current restaurant

Every page starts with this pattern to get the active restaurant:

```ts
const { data: restaurant } = useQuery<any>({ queryKey: ["/api/restaurants/current"] });
const restaurantId = restaurant?.id || 1;
```

---

## 5. Development Workflow

### Running locally

```bash
npm install
npm run dev           # starts on http://localhost:5000
```

### Type checking

```bash
npm run check         # TypeScript type check
```

### Build for production

```bash
npm run build         # compiles to dist/
npm run start         # runs production build
```

### Pushing schema changes to the database

```bash
npm run db:push       # requires DATABASE_URL env variable (set on Railway)
```

This command only works when `DATABASE_URL` is available. Locally you need a `.env` file with:
```
DATABASE_URL=postgresql://user:password@host:port/dbname
SESSION_SECRET=any-random-string
```

### Git workflow

- Always work on branch: `claude/hosting-platform-decision-P7TSB`
- Commit with descriptive messages
- Push with: `git push -u origin claude/hosting-platform-decision-P7TSB`

---

## 6. Current State — What Is Already Built

### Core pages (27 total)

| Page | Route | Description |
|---|---|---|
| Landing | `/` | Public marketing page |
| Login | `/login` | Authentication |
| Register | `/register` | User sign-up |
| Dashboard | `/app` | KPI overview, revenue trends |
| Quick Assessment | `/app/quick-assessment` | 30-second snapshot |
| Menu & Recipes | `/app/menu-costing` | Ingredient-level recipe costing |
| Menu Engineering | `/app/menu-engineering` | Profitability by dish |
| Supplier Risk | `/app/supplier-risk` | Supplier dependency analysis |
| Cost Classification | `/app/cost-classification` | Direct / indirect / overhead |
| Delivery Platforms | `/app/delivery-platforms` | Uber Eats / Deliveroo margins |
| Promotions | `/app/promotions` | Discount impact modelling |
| Breakeven Analysis | `/app/breakeven` | Breakeven calculations |
| Expense Intelligence | `/app/expense-intelligence` | Cost driver variance |
| Process Flow | `/app/process-flow` | Visual value chain |
| What-If Simulator | `/app/simulator` | Scenario modelling |
| Recommendations | `/app/recommendations` | AI-style insights |
| Add Data | `/app/add-data` | Manual financial data entry |
| Import Data | `/app/data-import` | CSV bulk import |
| Drill Down | `/app/drill-down` | Clickable metric explorer |
| Period Comparison | `/app/performance-comparison` | Quarter / half-year comparison |
| Franchise Hub | `/app/franchise-hub` | Franchisor network management |
| Supplier Intelligence | `/app/supplier-intelligence` | Price benchmarking |
| **Stock Levels** | `/app/inventory` | ✅ NEW — Inventory tracking |
| **Waste Log** | `/app/waste-log` | ✅ NEW — Waste event logging |
| Admin | `/app/admin` | Admin dashboard |
| Not Found | — | 404 page |

### Database tables (21 total)

| Table | Purpose |
|---|---|
| `restaurants` | Restaurant profile and subscription |
| `users` | User accounts |
| `user_restaurant_access` | Multi-restaurant access control |
| `monthly_data` | Monthly financial entries |
| `weekly_data` | Weekly financial entries |
| `cost_categories` | Default cost category definitions |
| `restaurant_cost_items` | Per-restaurant cost customisations |
| `suppliers` | Supplier profiles |
| `ingredients` | Ingredient master data with pricing |
| `supplier_ingredients` | Supplier ↔ ingredient price mappings |
| `menu_items` | Menu dishes |
| `menu_item_ingredients` | Recipe compositions |
| `promotions` | Discount campaigns |
| `franchise_groups` | Franchise brand entities |
| `franchise_memberships` | Restaurant ↔ franchise relationships |
| `franchise_approved_suppliers` | Franchisor-approved supplier list |
| `supplier_price_reports` | Franchisee price submissions |
| `inventory_items` | ✅ NEW — Stock levels per ingredient |
| `waste_logs` | ✅ NEW — Waste event records |

---

## 7. Module Build Status

| # | Module | Status |
|---|---|---|
| 1 | Inventory & Waste Management | ✅ Complete |
| 2 | Staff Labor Scheduling & Efficiency | ⬜ Not started |
| 3 | Cash Flow Forecasting (12-week) | ⬜ Not started |
| 4 | Marketing Attribution & Promotion ROI | ⬜ Not started |
| 5 | Customer Intelligence & Lifetime Value | ⬜ Not started |
| 6 | Predictive Analytics & Demand Forecasting | ⬜ Not started |
| 7 | POS & Accounting Integrations (Xero, QuickBooks) | ⬜ Not started |

---

## 8. Completed Module: Inventory & Waste Management

### What was built

**New database tables** in `shared/schema.ts`:
- `inventory_items` — tracks current stock, par level, storage location per ingredient
- `waste_logs` — records each waste event (item, qty, cost, reason, date)

**New storage methods** in `server/storage.ts`:
- `getInventoryItems(restaurantId)`, `getInventoryItem(id)`, `createInventoryItem`, `updateInventoryItem`, `deleteInventoryItem`
- `getWasteLogs(restaurantId)`, `createWasteLog`, `deleteWasteLog`

**New API routes** in `server/routes.ts`:
- `GET/POST/PUT/DELETE /api/inventory-items/:restaurantId`
- `GET/POST/DELETE /api/waste-logs/:restaurantId`
- `GET /api/waste-analytics/:restaurantId` — computed analytics (no extra storage cost)

**New pages:**
- `client/src/pages/inventory.tsx` — stock levels, par level alerts, inline editing, filter by location
- `client/src/pages/waste-log.tsx` — waste logging, reason analysis, monthly trend charts, top wasted items

**Navigation:** Sidebar section "Inventory & Waste" with links to both pages.

---

## 9. Module 2: Staff Labor Scheduling & Efficiency

### Goal
Track staff rotas, actual hours worked, labour cost per shift, and compare scheduled vs actual labour spend. Show efficiency KPIs (revenue per labour hour, labour % of revenue by day).

### New database tables needed

```ts
// In shared/schema.ts

export const staffMembers = pgTable("staff_members", {
  id: serial("id").primaryKey(),
  restaurantId: integer("restaurant_id").notNull(),
  name: text("name").notNull(),
  role: text("role").notNull(),           // chef, waiter, manager, barista, etc.
  employmentType: text("employment_type").notNull().default("full_time"), // full_time, part_time, zero_hours
  hourlyRate: real("hourly_rate").notNull(),
  isActive: boolean("is_active").notNull().default(true),
});

export const shifts = pgTable("shifts", {
  id: serial("id").primaryKey(),
  restaurantId: integer("restaurant_id").notNull(),
  staffMemberId: integer("staff_member_id").notNull(),
  date: text("date").notNull(),           // YYYY-MM-DD
  startTime: text("start_time").notNull(), // HH:MM (24hr)
  endTime: text("end_time").notNull(),
  scheduledHours: real("scheduled_hours").notNull(),
  actualHours: real("actual_hours"),      // filled in after shift
  role: text("role").notNull(),           // role on this specific shift
  status: text("status").notNull().default("scheduled"), // scheduled, completed, absent, sick
  notes: text("notes"),
});
```

### New storage methods needed

Add to `IStorage` interface and `DatabaseStorage` class in `server/storage.ts`:

```ts
getStaffMembers(restaurantId: number): Promise<StaffMember[]>
createStaffMember(data: InsertStaffMember): Promise<StaffMember>
updateStaffMember(id: number, data: Partial<InsertStaffMember>): Promise<StaffMember>
deleteStaffMember(id: number): Promise<void>
getShifts(restaurantId: number): Promise<Shift[]>
getShiftsByDateRange(restaurantId: number, startDate: string, endDate: string): Promise<Shift[]>
createShift(data: InsertShift): Promise<Shift>
updateShift(id: number, data: Partial<InsertShift>): Promise<Shift>
deleteShift(id: number): Promise<void>
```

### New API routes needed

Add to `server/routes.ts`:

```
GET    /api/staff-members/:restaurantId
POST   /api/staff-members
PUT    /api/staff-members/:id
DELETE /api/staff-members/:id
GET    /api/shifts/:restaurantId
POST   /api/shifts
PUT    /api/shifts/:id
DELETE /api/shifts/:id
GET    /api/labour-analytics/:restaurantId   ← computed: labour % by week, rev per hour, etc.
```

### New pages needed

**`client/src/pages/staff-scheduling.tsx`** — route: `/app/staff-scheduling`
- KPI cards: total weekly hours scheduled, total weekly labour cost, labour % of revenue, revenue per labour hour
- Weekly calendar view (Mon–Sun) showing shifts per day
- Add shift dialog (pick staff member, date, start/end time)
- Mark shift as completed with actual hours
- Colour code by role

**`client/src/pages/labour-efficiency.tsx`** — route: `/app/labour-efficiency`
- Labour cost trend chart (bar chart by week/month)
- Labour % of revenue over time (line chart)
- Revenue per labour hour trend
- Scheduled vs actual hours comparison
- Best/worst performing days by labour efficiency
- Staff member breakdown (who costs most, who drives most revenue hours)

### Sidebar navigation

Add a new section "Staff & Labour" in `app-sidebar.tsx`:
```ts
const staffNav = [
  { title: "Scheduling", url: "/app/staff-scheduling", icon: CalendarDays },
  { title: "Labour Efficiency", url: "/app/labour-efficiency", icon: Users },
];
```

### Key calculations

```
Labour % = (total labour cost / revenue) × 100          → target: 25–35%
Revenue per labour hour = revenue / total hours worked
Scheduled vs actual variance = actual hours - scheduled hours
Labour cost per cover = total labour cost / total covers
```

---

## 10. Module 3: Cash Flow Forecasting (12-week)

### Goal
Project the next 12 weeks of cash flow using historical data. Show expected revenue, expected costs, expected net cash position week by week, and cumulative cash balance.

### New database tables needed

```ts
// In shared/schema.ts

export const cashFlowEntries = pgTable("cash_flow_entries", {
  id: serial("id").primaryKey(),
  restaurantId: integer("restaurant_id").notNull(),
  weekNumber: integer("week_number").notNull(),
  year: integer("year").notNull(),
  type: text("type").notNull(),           // 'actual' or 'forecast'
  expectedRevenue: real("expected_revenue").notNull(),
  expectedFoodCost: real("expected_food_cost").notNull(),
  expectedLabourCost: real("expected_labour_cost").notNull(),
  expectedFixedCosts: real("expected_fixed_costs").notNull(),   // rent + energy + technology
  expectedVariableCosts: real("expected_variable_costs").notNull(), // other costs
  actualRevenue: real("actual_revenue"),
  actualTotalCosts: real("actual_total_costs"),
  notes: text("notes"),
});
```

### No new storage complexity needed

The forecasting logic is mostly computed from existing `weekly_data` and `monthly_data` tables. The `cash_flow_entries` table stores manual adjustments/overrides on top of auto-forecasts.

### New API routes needed

```
GET  /api/cash-flow-forecast/:restaurantId   ← auto-generates 12-week forecast from history
GET  /api/cash-flow-entries/:restaurantId    ← user's manual overrides
POST /api/cash-flow-entries                  ← save override for a specific week
PUT  /api/cash-flow-entries/:id
```

### Forecast algorithm (no ML, no external APIs)

Use a simple **weighted moving average** of the last 8 weeks of `weekly_data`:

```ts
// In routes.ts forecast endpoint:
const last8Weeks = weeklyData.slice(-8);
const weights = [0.05, 0.08, 0.10, 0.12, 0.15, 0.17, 0.18, 0.15]; // recent weeks weighted higher
const forecastRevenue = last8Weeks.reduce((sum, w, i) => sum + w.revenue * weights[i], 0);

// Apply seasonality: compare same week last year if data exists
// Apply trend: calculate week-over-week growth rate
```

### New page needed

**`client/src/pages/cash-flow.tsx`** — route: `/app/cash-flow`
- 12-week table (current week + 11 ahead) with:
  - Expected revenue, costs, net cash per week
  - Cumulative cash balance running total
  - Colour coded: green (positive), amber (< 20% buffer), red (negative)
- Area chart showing cumulative cash position over 12 weeks
- "What-if" override: click any week to adjust a forecast figure
- Scenario labels: Base case / Optimistic (+10%) / Pessimistic (-10%)
- Alert if any week projects negative cash

### Sidebar navigation

Add to the "Analysis" section in `app-sidebar.tsx`:
```ts
{ title: "Cash Flow Forecast", url: "/app/cash-flow", icon: TrendingUp },
```

---

## 11. Module 4: Marketing Attribution & Promotion ROI

### Goal
Track which marketing channels drive revenue, calculate true ROI per campaign, and show the promotion ROI separate from what the basic Promotions page already shows.

### New database tables needed

```ts
// In shared/schema.ts

export const marketingCampaigns = pgTable("marketing_campaigns", {
  id: serial("id").primaryKey(),
  restaurantId: integer("restaurant_id").notNull(),
  name: text("name").notNull(),
  channel: text("channel").notNull(), // social_media, email, flyer, google_ads, influencer, loyalty, word_of_mouth
  startDate: text("start_date").notNull(), // YYYY-MM-DD
  endDate: text("end_date"),
  spend: real("spend").notNull().default(0),
  targetCovers: integer("target_covers"),
  isActive: boolean("is_active").notNull().default(true),
  notes: text("notes"),
});

export const campaignResults = pgTable("campaign_results", {
  id: serial("id").primaryKey(),
  campaignId: integer("campaign_id").notNull(),
  restaurantId: integer("restaurant_id").notNull(),
  weekNumber: integer("week_number").notNull(),
  year: integer("year").notNull(),
  attributedCovers: integer("attributed_covers").notNull().default(0),
  attributedRevenue: real("attributed_revenue").notNull().default(0),
  newCustomers: integer("new_customers").notNull().default(0),
  returnCustomers: integer("return_customers").notNull().default(0),
});
```

### Key calculations

```
ROI % = ((attributed_revenue - spend) / spend) × 100
Cost per cover = spend / attributed_covers
Revenue per £ spent = attributed_revenue / spend
Customer acquisition cost = spend / new_customers
```

### New pages needed

**`client/src/pages/marketing-attribution.tsx`** — route: `/app/marketing-attribution`
- Campaign manager: create, track, close campaigns
- KPI cards: total marketing spend, blended ROI, best performing channel, cost per new cover
- Channel comparison bar chart (ROI by channel)
- Campaign timeline view
- Weekly attributed revenue vs spend chart

### Sidebar navigation

Add to "Analysis" section in `app-sidebar.tsx`:
```ts
{ title: "Marketing ROI", url: "/app/marketing-attribution", icon: Megaphone },
```

---

## 12. Module 5: Customer Intelligence & Lifetime Value

### Goal
Track customer visit frequency, average spend, identify VIP customers, calculate Customer Lifetime Value (CLV), and segment customers for targeted promotions.

### New database tables needed

```ts
// In shared/schema.ts

export const customers = pgTable("customers", {
  id: serial("id").primaryKey(),
  restaurantId: integer("restaurant_id").notNull(),
  name: text("name"),                    // optional if anonymous
  email: text("email"),
  phone: text("phone"),
  source: text("source").notNull().default("walkin"), // walkin, booking, delivery, loyalty_app
  firstVisitDate: text("first_visit_date").notNull(), // YYYY-MM-DD
  totalVisits: integer("total_visits").notNull().default(1),
  totalSpend: real("total_spend").notNull().default(0),
  lastVisitDate: text("last_visit_date"),
  notes: text("notes"),
  isActive: boolean("is_active").notNull().default(true),
});

export const customerVisits = pgTable("customer_visits", {
  id: serial("id").primaryKey(),
  customerId: integer("customer_id").notNull(),
  restaurantId: integer("restaurant_id").notNull(),
  visitDate: text("visit_date").notNull(), // YYYY-MM-DD
  spend: real("spend").notNull(),
  covers: integer("covers").notNull().default(1),
  channel: text("channel").notNull().default("dine_in"), // dine_in, delivery, takeaway
  menuItems: text("menu_items"),          // comma-separated item names (simple, no FK needed)
  notes: text("notes"),
});
```

### Key calculations

```
CLV (simple) = avg_spend_per_visit × avg_visits_per_year × avg_customer_lifespan_years
CLV (advanced) = (avg_spend × gross_margin%) × (1 / (1 + discount_rate - retention_rate))
Churn risk = customers with no visit in >60 days
RFM score = Recency (last visit) + Frequency (visits/month) + Monetary (avg spend)
```

### New pages needed

**`client/src/pages/customer-intelligence.tsx`** — route: `/app/customer-intelligence`
- KPI cards: total customers, avg CLV, avg visit frequency, repeat rate %
- Customer segments: VIP (top 10% spend), Regular, At Risk (no visit 30–60 days), Lost (>60 days)
- CLV calculator (inputs: avg spend, visits/year, lifespan years)
- Top customers table (name, visits, total spend, last visit, CLV estimate)
- Cohort retention chart (by month of first visit)
- Churn alert list (customers at risk)

### Sidebar navigation

Add a new section "Customers" in `app-sidebar.tsx`:
```ts
const customerNav = [
  { title: "Customer Intelligence", url: "/app/customer-intelligence", icon: UserCheck },
];
```

---

## 13. Module 6: Predictive Analytics & Demand Forecasting

### Goal
Predict future revenue and cover counts based on historical patterns. Identify the best and worst performing days/periods. Help with stock ordering by predicting demand for key ingredients.

### No new database tables needed

This module is entirely computed from existing data:
- `weekly_data` — for revenue and cover trends
- `monthly_data` — for seasonal patterns
- `inventory_items` + `waste_logs` — for ingredient demand patterns
- `shifts` (from Module 2) — for staffing recommendations

### New API routes needed

```
GET /api/demand-forecast/:restaurantId     ← next 4-week revenue + cover predictions
GET /api/seasonal-patterns/:restaurantId   ← monthly/weekly seasonality index
GET /api/ingredient-demand/:restaurantId   ← predicted usage per ingredient next week
```

### Forecast algorithm (pure SQL/JS, no external AI)

```ts
// Simple seasonal decomposition:
// 1. Calculate baseline: 8-week moving average of covers/revenue
// 2. Calculate day-of-week index: (avg Monday covers) / (overall avg covers)
// 3. Calculate month seasonality: same month across years
// 4. Forecast = baseline × day_of_week_index × month_seasonality_index

// Ingredient demand forecast:
// predicted_usage = (forecasted_covers / historical_avg_covers) × historical_avg_usage_per_ingredient
```

### New page needed

**`client/src/pages/demand-forecast.tsx`** — route: `/app/demand-forecast`
- KPI cards: predicted revenue next 4 weeks, predicted covers, confidence level %
- 4-week forward forecast chart (bar + line) with historical actuals shown alongside
- Day-of-week heatmap (Mon–Sun by week showing predicted busy/quiet periods)
- Seasonal pattern chart (monthly index: 1.0 = average, >1.0 = busy season)
- Ingredient demand predictions table: "Order X kg of [ingredient] this week"
- Staffing recommendation: "Schedule X more staff on [busiest days]"

### Sidebar navigation

Add to "Analysis" section in `app-sidebar.tsx`:
```ts
{ title: "Demand Forecast", url: "/app/demand-forecast", icon: LineChart },
```

---

## 14. Module 7: POS & Accounting Integrations

### Goal
Connect RestaurantPulse to Xero (accounting), QuickBooks (accounting), and optionally POS systems (Square, Toast). Pull real financial data automatically instead of requiring manual entry.

### Architecture approach

This module is **significantly more complex** than the others. It requires OAuth flows for Xero/QuickBooks and webhook handling.

### New database tables needed

```ts
// In shared/schema.ts

export const integrations = pgTable("integrations", {
  id: serial("id").primaryKey(),
  restaurantId: integer("restaurant_id").notNull(),
  provider: text("provider").notNull(),           // xero, quickbooks, square, toast
  status: text("status").notNull().default("disconnected"), // connected, disconnected, error
  accessToken: text("access_token"),              // encrypted
  refreshToken: text("refresh_token"),            // encrypted
  tokenExpiresAt: timestamp("token_expires_at"),
  externalTenantId: text("external_tenant_id"),   // Xero tenant ID or QB realm ID
  lastSyncAt: timestamp("last_sync_at"),
  lastSyncStatus: text("last_sync_status"),        // success, failed
  lastSyncError: text("last_sync_error"),
  createdAt: timestamp("created_at").notNull().default(sql`CURRENT_TIMESTAMP`),
});

export const syncLogs = pgTable("sync_logs", {
  id: serial("id").primaryKey(),
  integrationId: integer("integration_id").notNull(),
  syncedAt: timestamp("synced_at").notNull().default(sql`CURRENT_TIMESTAMP`),
  recordsImported: integer("records_imported").notNull().default(0),
  status: text("status").notNull(),               // success, partial, failed
  errorMessage: text("error_message"),
});
```

### External API credentials needed (from client)

The restaurant owner must provide these credentials — they are NOT included in the codebase:

| Integration | What is needed | Where to get it |
|---|---|---|
| Xero | Client ID + Client Secret | https://developer.xero.com |
| QuickBooks | Client ID + Client Secret | https://developer.intuit.com |
| Square | Application ID + Access Token | https://developer.squareup.com |

Store these as environment variables on Railway:
```
XERO_CLIENT_ID=
XERO_CLIENT_SECRET=
XERO_REDIRECT_URI=https://your-app.railway.app/api/integrations/xero/callback
QB_CLIENT_ID=
QB_CLIENT_SECRET=
QB_REDIRECT_URI=https://your-app.railway.app/api/integrations/quickbooks/callback
```

### OAuth flow (Xero example)

```
1. User clicks "Connect Xero" → POST /api/integrations/xero/connect
2. Server generates Xero OAuth URL → redirect user to Xero login
3. Xero redirects back → GET /api/integrations/xero/callback?code=xxx
4. Server exchanges code for access + refresh tokens
5. Tokens stored (encrypted) in integrations table
6. Server fetches accounts/invoices from Xero API
7. Data mapped to RestaurantPulse monthly_data format and saved
```

### npm packages needed

```bash
npm install xero-node            # Xero SDK
npm install intuit-oauth         # QuickBooks OAuth
npm install node-fetch           # HTTP requests (already available via Node 18)
npm install crypto               # for token encryption (built-in to Node)
```

### New page needed

**`client/src/pages/integrations.tsx`** — route: `/app/integrations`
- Integration cards (Xero, QuickBooks, Square, Toast POS)
- Each card shows: Connected / Disconnected status, last sync time, records imported
- "Connect" button → triggers OAuth flow
- "Sync Now" button → manually triggers a data pull
- Sync log history table
- Field mapping explanation ("Where does this data go in RestaurantPulse?")

### Sidebar navigation

Add a new section "Integrations" in `app-sidebar.tsx`:
```ts
const integrationsNav = [
  { title: "Integrations", url: "/app/integrations", icon: Plug },
];
```

---

## 15. Architecture Patterns — How to Add a New Module

Follow these exact steps every time:

### Step 1 — Schema (`shared/schema.ts`)

```ts
// 1a. Define the table
export const myNewTable = pgTable("my_new_table", {
  id: serial("id").primaryKey(),
  restaurantId: integer("restaurant_id").notNull(),
  // ... your columns
});

// 1b. Create insert schema (always omit id and auto timestamps)
export const insertMyNewTableSchema = createInsertSchema(myNewTable).omit({ id: true });

// 1c. Export TypeScript types
export type MyNewTable = typeof myNewTable.$inferSelect;
export type InsertMyNewTable = z.infer<typeof insertMyNewTableSchema>;
```

### Step 2 — Storage (`server/storage.ts`)

```ts
// 2a. Add import at top
import { myNewTable, type MyNewTable, type InsertMyNewTable } from "@shared/schema";

// 2b. Add to IStorage interface
getMyNewItems(restaurantId: number): Promise<MyNewTable[]>;
createMyNewItem(data: InsertMyNewTable): Promise<MyNewTable>;
updateMyNewItem(id: number, data: Partial<InsertMyNewTable>): Promise<MyNewTable>;
deleteMyNewItem(id: number): Promise<void>;

// 2c. Implement in DatabaseStorage class
async getMyNewItems(restaurantId: number): Promise<MyNewTable[]> {
  return db.select().from(myNewTable).where(eq(myNewTable.restaurantId, restaurantId));
}
// ... etc
```

### Step 3 — Routes (`server/routes.ts`)

```ts
// 3a. Add import at top
import { insertMyNewTableSchema } from "@shared/schema";

// 3b. Add routes before the final `return httpServer;`
app.get("/api/my-new-items/:restaurantId", async (req, res) => {
  try {
    const restaurantId = parseInt(req.params.restaurantId);
    if (isNaN(restaurantId)) return res.status(400).json({ message: "Invalid restaurant ID" });
    const data = await storage.getMyNewItems(restaurantId);
    res.json(data);
  } catch (error) {
    res.status(500).json({ message: "Failed to fetch items" });
  }
});
```

### Step 4 — React Page (`client/src/pages/my-page.tsx`)

```tsx
export default function MyPage() {
  const { data: restaurant } = useQuery<any>({ queryKey: ["/api/restaurants/current"] });
  const restaurantId = restaurant?.id || 1;

  const { data: items = [] } = useQuery<MyNewTable[]>({
    queryKey: ["/api/my-new-items", restaurantId],
  });

  const createMutation = useMutation({
    mutationFn: (data: any) => apiRequest("POST", "/api/my-new-items", data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/my-new-items", restaurantId] });
      toast({ title: "Item created" });
    },
  });

  return (
    <div className="p-4 md:p-6 space-y-6 max-w-7xl mx-auto" data-testid="page-my-page">
      <h1 className="text-2xl font-bold">My Page</h1>
      {/* ... */}
    </div>
  );
}
```

### Step 5 — Register Route (`client/src/App.tsx`)

```tsx
import MyPage from "@/pages/my-page";
// Inside AppRouter:
<Route path="/app/my-page" component={MyPage} />
```

### Step 6 — Sidebar (`client/src/components/app-sidebar.tsx`)

```tsx
// Add icon import at top
import { SomeIcon } from "lucide-react";

// Add nav array
const myNewNav = [
  { title: "My Page", url: "/app/my-page", icon: SomeIcon },
];

// Inside AppSidebar JSX
<SidebarSeparator />
<NavGroup label="My Section" items={myNewNav} />
```

### Step 7 — Push schema to Railway

```bash
git add -A && git commit -m "Add [module name] module"
git push -u origin claude/hosting-platform-decision-P7TSB
# Railway auto-deploys and runs npm run db:push on startup
```

---

## 16. Database Schema Reference

### Full list of tables (as of Feb 2026)

```
restaurants              — restaurant profile, subscription status
users                    — user accounts (username, password hash, role)
user_restaurant_access   — which users can access which restaurants
monthly_data             — monthly revenue + cost breakdown
weekly_data              — weekly revenue + cost breakdown
cost_categories          — the 12 default cost category definitions
restaurant_cost_items    — per-restaurant customisations of cost categories
suppliers                — supplier profiles
ingredients              — ingredient master data (name, unit, price, VAT)
supplier_ingredients     — supplier ↔ ingredient price mappings
menu_items               — menu dishes with selling price
menu_item_ingredients    — recipe = dish → ingredient quantities
promotions               — discount campaigns
franchise_groups         — franchise brand entities
franchise_memberships    — restaurant ↔ franchise group relationships
franchise_approved_suppliers — approved supplier list per franchise group
supplier_price_reports   — franchisee price submissions for intelligence
inventory_items          — current stock levels per ingredient
waste_logs               — waste event records
```

### Field naming convention

- Use `camelCase` in TypeScript / Drizzle schema definitions
- Use `snake_case` in the actual PostgreSQL column names (Drizzle handles translation)
- Always include `restaurantId: integer("restaurant_id").notNull()` for tenant isolation
- Primary keys: always `id: serial("id").primaryKey()`
- Booleans: always provide `.notNull().default(true/false)`
- Timestamps: use `timestamp("created_at").notNull().default(sql\`CURRENT_TIMESTAMP\`)`

---

## 17. API Endpoints Reference

### Naming convention

All routes follow: `/api/[resource-plural]/[restaurantId-or-id]`

### All current endpoints

```
Auth
  POST /api/auth/register
  POST /api/auth/login
  POST /api/auth/logout
  GET  /api/auth/user

Restaurants
  GET  /api/restaurants/current
  GET  /api/restaurants
  POST /api/restaurants

Financial Data
  GET  /api/monthly-data/:restaurantId
  POST /api/monthly-data
  GET  /api/weekly-data/:restaurantId
  POST /api/weekly-data

Cost Management
  GET  /api/cost-categories
  POST /api/cost-categories
  GET  /api/restaurant-cost-items/:restaurantId
  POST /api/restaurant-cost-items
  PUT  /api/restaurant-cost-items/:id
  POST /api/restaurant-cost-items/bulk/:restaurantId

Suppliers
  GET    /api/suppliers/:restaurantId
  POST   /api/suppliers
  PUT    /api/suppliers/:id
  DELETE /api/suppliers/:id

Ingredients
  GET    /api/ingredients/:restaurantId
  POST   /api/ingredients
  PUT    /api/ingredients/:id
  DELETE /api/ingredients/:id

Supplier ↔ Ingredient
  GET    /api/supplier-ingredients/:supplierId
  GET    /api/ingredient-suppliers/:ingredientId
  POST   /api/supplier-ingredients
  DELETE /api/supplier-ingredients/:id

Menu Items
  GET    /api/menu-items/:restaurantId
  POST   /api/menu-items
  PUT    /api/menu-items/:id
  DELETE /api/menu-items/:id

Recipes (Menu Item → Ingredients)
  GET  /api/menu-item-ingredients/:menuItemId
  POST /api/menu-item-ingredients/bulk/:menuItemId

Promotions
  GET    /api/promotions/:restaurantId
  POST   /api/promotions
  PUT    /api/promotions/:id
  DELETE /api/promotions/:id

Bulk Import (CSV)
  POST /api/import/ingredients
  POST /api/import/suppliers
  POST /api/import/menu-items

Period Comparisons
  GET /api/comparisons/quarterly
  GET /api/comparisons/half-yearly
  GET /api/comparisons/weekly

Franchise
  GET    /api/franchise-groups/owner/:ownerId
  GET    /api/franchise-groups/:id
  POST   /api/franchise-groups
  PUT    /api/franchise-groups/:id
  GET    /api/franchise-memberships/:franchiseGroupId
  GET    /api/franchise-memberships/restaurant/:restaurantId
  POST   /api/franchise-memberships
  DELETE /api/franchise-memberships/:id
  GET    /api/franchise-approved-suppliers/:franchiseGroupId
  POST   /api/franchise-approved-suppliers
  PUT    /api/franchise-approved-suppliers/:id
  DELETE /api/franchise-approved-suppliers/:id
  POST   /api/supplier-price-reports
  GET    /api/supplier-price-reports/group/:franchiseGroupId
  GET    /api/supplier-price-reports/restaurant/:restaurantId
  GET    /api/supplier-intelligence/:restaurantId/:franchiseGroupId
  GET    /api/franchise-analytics/:franchiseGroupId

Inventory & Waste (Module 1 - NEW)
  GET    /api/inventory-items/:restaurantId
  POST   /api/inventory-items
  PUT    /api/inventory-items/:id
  DELETE /api/inventory-items/:id
  GET    /api/waste-logs/:restaurantId
  POST   /api/waste-logs
  DELETE /api/waste-logs/:id
  GET    /api/waste-analytics/:restaurantId

System
  GET  /api/health
```

---

## 18. Railway Deployment Notes

### How deployment works

1. Push to branch → Railway detects the push
2. Railway runs: `npm run build` → compiles TypeScript to `dist/`
3. Railway runs: `npm run start` → starts `dist/index.cjs`
4. On startup, `server/index.ts` calls `npm run db:push` equivalent via Drizzle to apply any new schema changes

### Environment variables required on Railway

| Variable | Purpose |
|---|---|
| `DATABASE_URL` | PostgreSQL connection string (auto-set by Railway Postgres plugin) |
| `SESSION_SECRET` | Any long random string for session signing |
| `NODE_ENV` | Set to `production` |
| `PORT` | Auto-set by Railway (do not override) |

### Health check

Railway calls `GET /api/health` every 30 seconds. This endpoint must return `200 OK`. It is defined in `server/routes.ts`.

### Cost profile on Railway

With current usage (~50MB RAM, minimal CPU):
- **Estimated monthly cost:** £0.04–£0.50
- **Hobby plan credit:** £5.00/month
- **Multiple apps:** Can run 10–15 small apps within the £5 credit

---

## 19. Cost Management Principles

These principles must be followed for every module to keep Railway costs minimal:

| Principle | How it is applied |
|---|---|
| **No paid external APIs** | All analytics computed in PostgreSQL or in-memory JS — no OpenAI, no analytics SaaS |
| **No background workers** | No cron jobs, no scheduled tasks — computations run on-demand when a user loads the page |
| **No Redis / caching layer** | Direct database queries are fast enough at this scale |
| **Computed analytics endpoints** | Complex analytics (e.g. `/api/waste-analytics`) are computed at request time from raw data, not stored separately |
| **No file storage** | No AWS S3 or file uploads — use database text fields for any needed content |
| **No WebSockets** | No real-time features — React Query polling is sufficient |
| **Lean dependencies** | Do not add npm packages unless absolutely necessary — each adds to bundle size and build time |
| **Reuse existing tables** | Before creating a new table, check if an existing table can be extended |

---

*End of document. For questions, refer to the codebase or contact the original developer.*
